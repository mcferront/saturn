■目次
  ・基本コンセプト
  ・ＳＢＬのペリフェラルライブラリに対する高水準Ｉ／Ｆライブラリ
  ・ファイル一覧
  ・使用方法
  ・現状で対応している入力ペリフェラルデバイス
  
  注意：この高水準Ｉ／Ｆライブラリは、既存のペリフェラルライブラリを下位モ
  ジュールとして使用しています。したがって、既存のペリフェラルライブラリを
  使用する上での注意点や約束ごとなどは、この高水準Ｉ／Ｆライブラリにも適用
  されます。



■基本コンセプト
  ＳＢＬのペリフェラルライブラリが返すデータ構造を次に示す：
    struct port_t {
        struct peripheral_t {
            Uint8   type;
            Uint8   size;
            Uint8   data[m];
        } peripheral[n];
    } port[2];
    ここで m は、PER_LInit() で指定されたデータサイズ。
           n は、PER_LInit() で指定された認識可能なペリフェラルの最大数÷２。
           （ただし、m,n は常に 1 以上）
  
  ライブラリでは、上記の m,n の値がコンパイル時には決定できないために、構
  造体を使わず、単なるバイトの配列として実装している。上記の構造体を使って
  ライブラリの返すデータにアクセスしたいときには、次のようにするとよい：
    PER_LInit( PER_KD_PER, 2*n, m, port, 0 );
  
  高水準Ｉ／Ｆライブラリの基本は、要するに、こういうことである：
    「ライブラリの返すデータに構造体でアクセスしたい。」



■ＳＢＬのペリフェラルライブラリに対する高水準Ｉ／Ｆライブラリ
  現在のペリフェラルライブラリは、ＳＭＰＣからデータを得て、それをバッファ
  に入れてくれるだけで、そこから先のことはすべて自分でやらなければなりませ
  ん。例えば、下記のようなことは「トリガ情報を得る」もっとも基本的な処理で
  すが、現在のライブラリの機能だけでは、これをすべて自分で（アプリケーショ
  ン側で）やらなければなりません。
    
  「トリガ情報を得る処理
    ある位置に挿されているデバイスからペリフェラルデータを得ます。
    ＩＤをチェックして、未接続や不明なデバイスではないことを確認します。
    「ｔｈｅｎ
      ＩＤをチェックして、デバイスの種類を判断します。
      デバイスの種類に応じて、ペリフェラルデータからトリガ情報を得ます。
      （その際、「ペリフェラルデータの何バイト目のどのビットが何を意味して
      いるか」などといったことについても、自分が（アプリケーション側が）知っ
      ていなければなりません。）
      キーアサインが変更されていたら、トリガ情報を加工します。
    」
  」
  
  ここで何かに気付きませんか？
  上記の処理は、トリガ情報を得る処理だと言いました。そして、それが一般的な
  処理であるとも言いました。つまり、上記の処理をトリガ情報を得るという関数
  にしてしまえばよいのではないか、ということです。当然そのとおりです。そこ
  で、このライブラリの登場です。
  
  このライブラリは、自分ではペリフェラルデータの収集などといった物理的な処
  理は一切やりません。そういった側面は既存のペリフェラルライブラリにまかせ
  て、そこから得られたデータに対する論理的な処理だけをやります。そのため、
  現在のペリフェラルライブラリは完全に使うことができます。このライブラリは、
  新しいペリフェラルライブラリではないのですから、既存のペリフェラルライブ
  ラリと差し替えることはしません。このライブラリの機能が使いたいプロジェク
  トでは、既存のペリフェラルライブラリと共に、このライブラリもリンクしてく
  ださい。このライブラリの機能が必要ないというプロジェクトでは、何も変える
  必要はありません。従来のペリフェラルライブラリの動作は完全に保証されます。
  
  このライブラリで定義されている関数や、オブジェクトなどの詳細については、
  付属のリファレンスマニュアルやソースコードを参照してください。



■ファイル一覧
  per_1.c      高水準 I/F ライブラリのソース
  per_2.c      ３つの定数に依存する関数群
  per_3.src    PER_DisguiseTrigger() を高速化するためにアセンブラにしてある。
  
  per_x.h      高水準 I/F 機能に関する定義
  per_trg.h    トリガ情報に関する定義
  per_dev.h    一般的なデバイスに関する定義
  per_dgt.h    デジタルデバイスに関する定義
  per_anlg.h   アナログデバイスに関する定義
  per_poin.h   ポインティングデバイスに関する定義
  per_kbrd.h   キーボードデバイスに関する定義
  per_md.h     メガドライブ用デバイスに関する定義



■使用方法
  smpclib.h に定義されている３つの定数の値を適宜変更して、再コンパイルし、
  既存のペリフェラルライブラリと共にリンクして使用してください。
  これらの値から、既存のペリフェラルライブラリが使用するワークエリアのサイ
  ズを決定します。
  以下にデフォルトの設定値を示しておきます。このデフォルト値で構わない場合
  には、再コンパイルの必要はありませんので、そのままリンクして使用して頂け
  ます。
  
  _MAX_PORT
    デフォルトでは、2 に設定してあります。
    ＳＡＴＵＲＮ本体についている端子の数
    （通常は、2 に設定しておきます）
  _MAX_PERIPHERAL
    デフォルトでは、6 に設定してあります。
    １つの端子に接続可能なペリフェラルの数
    （通常は、マルチターミナル６に対応するために 6 以上に設定しておきます）
  SZ_PERIPHERAL
    デフォルトでは、5 に設定してあります。
    １つのペリフェラルのデータサイズの最大
    たとえば、マウス（データサイズ==3）とデジタルパッド（データサイズ==2）
    の両方をサポートするなら、情報量の多いマウスにあわせて設定します。
    現在のところ、データサイズの最大はアナログデバイスの 5 です。
  
  □処理手順
  １．ペリフェラルＩ／Ｆの環境を初期化します。
      PER_OpenPort() をコールします。
  ２．V BLANK OUT 割り込みハンドラを登録します。
      中で PER_GetPort() をコールする V BLANK OUT 割り込みハンドラを用意し、
      それをベクタに登録します。
  ３．指定した入力ペリフェラルデバイスの情報を得ます。
      PER_GetDevice?() をコールします。
  ４．３で得た情報から、必要な情報（トリガデータなど）を取り出します。
      PER_GetTrigger() など。



■現状での対応／未対応な入力ペリフェラルデバイス
  □対応している入力ペリフェラルデバイス
    コントロールパッド      ＨＳＳ−０１０１
    シャトルマウス          ＨＳＳ−０１０２
    マルチターミナル６      ＨＳＳ−０１０３
    バーチャスティック      ＨＳＳ−０１０４
    レーシングコントローラ  ＨＳＳー０１１５
    
    上記ペリフェラル、あるいは、上記ペリフェラル互換の入力ペリフェラルに対
    応しています。
    
    対応しているペリフェラルタイプを以下に記しておきます。
    デジタルデバイス（ペリフェラルタイプ＝０）
      コントロールパッド、バーチャスティックなど
    アナログデバイス（ペリフェラルタイプ＝１）
      レーシングコントローラなど
    ポインティングデバイス（ペリフェラルタイプ＝２）
      シャトルマウスなど
    キーボードデバイス（ペリフェラルタイプ＝３）
      現在のところ対応する製品はありません。
    メガドライブ用デバイス（ペリフェラルタイプ＝Ｅ）
      現在のところ対応する製品はありません。
    
    注意：シャトルマウスは実際にはＳＭＰＣに対してＩＤを H'E3 と返します。
    しかし、ペリフェラルライブラリによってＩＤを加工されてしまうので、デー
    タから得られるＩＤは H'23 になります。
  
  □その他のペリフェラル
    現状で判っているものでは、「バーチャガン」「ミッションスティック」の扱
    いには注意が必要です。
    
    バーチャガン
      既存のペリフェラルライブラリでは、ポートステータスを調べることによっ
      て、それが接続されていることは確認できますが、ほかのペリフェラルのよ
      うに、データはバッファに格納されません。したがって、アプリケーション
      側は、ＳＭＰＣをダイレクトモードにしてトリガ情報を得てください。また、
      ＨＶカウンタの値も自分で直接ＶＤＰ２から得てください。
    ミッションスティック
      マルチターミナル６に対応していないので、ポートに直接接続して使用する
      ようにしてください。それ以外の場合（マルチターミナル６に接続した場合）
      には、このペリフェラルだけでなく、ほかのペリフェラルのデータも読めな
      くなる可能性があります。



