
ＳＢＬ６．０スクロールライブラリ目次

１．ＳＢＬ６．０の概要
　　■従来のＳＢＬスクロール関数について
　　■拡張されたＳＧＬスクロール関数について
　　■バグのＦＩＸについて

２．ＳＢＬ６．０を導入するメリット、デメリット
　　■メリット
　　・ポリゴンと同じ座標系でスクロールも操作できる
　　・サイクルパターン作成が簡単

	■デメリット
　　・ＳＧＬのポリゴンを使用しない場合
　　・ＳＢＬオリジナルの回転スクロール関数は使用不可
　　・ＳＧＬの係数テーブルデータについて
　　・ＳＧＬワーク0x060ffc00が入ってしまう。

３．使い方
　　■ＳＢＬオリジナルで使う人
　　■ＳＢＬ＋ＳＧＬポリゴンで使う人
　　■ＳＢＬ＋ＳＧＬポリゴン＋ＳＧＬ回転スクロールで使う人

４．関数リファレンス

５．技術情報

　　■ＳＧＬとの融合のためSclRotregの構造体のサイズを変更した
　　■SclRotregBuffを配列からポインタに変更した

*****************************************************************************

１．ＳＢＬ６．０の概要
　　
　　■従来のＳＢＬスクロール関数について
　　　　これまで提供されていた関数は、ほぼ使用可能です。例外として、
　　　　スプライトライブラリで、ＳＧＬモードを使用する場合、一部の
　　　　関数の使用に制限ができます。これは、V_Syncの処理をＳＧＬと
　　　　ＳＢＬの間ですりあわせるためです。詳しくは、スプライト関数
　　　　のマニュアルと、このＳＢＬスクロール関数の使い方を参照して
　　　　ください。

　　■拡張されたＳＧＬスクロール関数について
　　　　サイクルパターン自動生成関数と回転スクロールの制御に関係した
　　　　関数が使用可能です。詳細はこれらの関数の使用法を参照してくだ
　　　　さい。

　　■バグのＦＩＸについて
　　　　・スクロールコンフィグレーションの設定関数で、回転パラメータＡ
　　　　と回転パラメータＢで違うマップアドレスを指定できなかったバグを
　　　　両方とも違うアドレスを指定できるように直しました。

*****************************************************************************

２．ＳＢＬ６．０を導入するメリット、デメリット

　　■メリット
　　　　・ＳＧＬは、ポリゴンマトリクスをスクロールで使用できるように
　　　　　なっています。すなわち、ポリゴンの座標系でスクロールも操作
　　　　　できましたが、従来のＳＢＬでこれを実現することは、容易では
　　　　　ありませんでした。ＳＢＬ６．０では、ＳＧＬに用意されている
　　　　　マトリクス関係の関数を利用して、スクロールの表示制御が可能
　　　　　になっています。

　　　　・分かりにくいといわれているサイクルパターンのセッティングが
　　　　　半自動で行えます。これまで、スクロール面を表示する場合に、
　　　　　プログラマーが最初に引っ掛かるのが、サイクルパターンの設定
　　　　　でした。ＳＢＬ６．０では、ＳＧＬのサイクルパターン自動生成
　　　　　関数を移植することにより、この作業を半自動化しています。
　　　　　しかしながら、最適化にも限界があるので、サイクルパターンに
　　　　　ついて完全に理解しており、なおかつ限界まで使用したい開発者は、
　　　　　この関数を使用するべきではありません。

　　■デメリット
　　　　・ＳＧＬのポリゴンを使用しない場合、ＳＢＬ６．０を導入する
　　　　　メリットは、大きく減ります。ポリゴンを独自のマトリクス演算
　　　　　で動作させている場合などでは、ＳＧＬモードの使用は、意味が
　　　　　ありません。

　　　　・移植されたＳＧＬスクロール関数を使用する場合、ＳＢＬオリジナル
　　　　　の回転マトリクス関数は、使用不可となります。これは、ＳＧＬと
　　　　　ＳＢＬでは、係数テーブルに関する考え方が根本的に異なるためです。
　　　　　ＳＢＬの回転マトリクス関数だけを使用しているのであれば、
　　　　　従来通りＳＢＬスクロール関数は正常動作します。

　　　　・ＳＧＬの係数テーブルデータは基本的にかなり荒いので、精密な絵を
　　　　　表示することには不向きです。付属のサンプルをみれば分かりますが
　　　　　かなり絵が崩れます。もし、精密な画像を表示しようとしているなら、
　　　　　ＳＧＬのスクロール関数は使用するべきではありません。

　　　　・ＳＧＬシステムワークが0x060ffc00からマップされます。これを動かす
　　　　　ことは不可能なため、この部分を別の目的で使用したいユーザは、
　　　　　ＳＧＬモードを使用することはできません。

****************************************************************************

３．ライブラリの使用方法

　　■ＳＢＬに従来から用意されている関数のみ使用する場合
　　　　なにも変更する必要はありません。基本的にすべての
　　　　関数が動作します。リンクするＬＩＢファイルも
　　　　これまでのものから変更する必要はありません

　　■ＳＢＬ＋ＳＧＬポリゴンで使用する場合
　　　　LIBSGLをリンクする必要があります。スクロールに関しては、
　　　　SCL_SetFrameInterval,SCL_DisplayFrameといった
　　　　V_syncに関係した関数は使用できません。またSCL_Vdp2Init
　　　　関数のかわりにＳＧＬに用意されているslInitSystem関数を
　　　　使用してください。
　　　　V_syncに関係した関数については、スプライトライブラリの
　　　　ＳＧＬモードのマニュアルを参照してください。

　　■ＳＢＬ＋ＳＧＬポリゴン＋ＳＧＬ回転スクロールで使用する場合
　　　　LIBSGLをリンクする必要があります。ノーマルスクロールに
　　　　関しては、ＳＢＬの関数がそのまま使用可能です。
　　　　そのほか、回転スクロール関数を使用したい場合、
　　　　初期化の際SCL_SglOn()を実行する必要があります。
　　　　また回転スクロールパラメータ関係の
　　　　　　slRparaInitSet
　　　　　　slRparaMode
　　　　係数テーブル関係の
　　　　　　slMakeKtable
　　　　　　slKtableRA
　　　　　　slKtableRB
　　　　これらの実行順序に制限がありますので、詳しくは関数リファレンス
　　　　を参照してください。

****************************************************************************

４．関数リファレンス

■void SCL_SglOn(void);

　　　　ＳＢＬスクロールでＳＧＬのフラグを立てます。
　　　　この関数を実行することで、ＳＧＬの回転スクロール関数を
　　　　使用することが可能になります。
　　　　具体的には、回転スクロールの回転パラメータバッファとして
　　　　ＳＧＬに用意されているバッファを使用するように
　　　　ポインタ変数を変更します。したがって、V_syncのパラメータ
　　　　転送の部分も、ＳＧＬのパラメータを転送します。

　　　　ＳＧＬの回転スクロール関数を使用したい場合
　　　　必ず、イニシャル処理でコールする必要があります。

■void SCL_SglOff(void);

　　　　スクロールワークでＳＧＬのフラグを解除します。
　　　　デフォルトでは、ＳＧＬスクロールはOFFの状態になっています。
　　　　拡張されたＳＧＬスクロール関数をdisableし、ＳＢＬ
　　　　スクロール関数を使用したいとき、使用してください。

■void slCurRpara(Uint16 flag);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、SCL_SglOnとslInitSystemをコールしておく必要が
　　　　あります。

■void slDispCenterR(FIXED x,FIXED y);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、SCL_SglOnとslInitSystemをコールしておく必要が
　　　　あります。

■void slKtableRA(void *ktable_adr ,Uint16 mode);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、SCL_SglOnとslInitSystemをコールしておく必要が
　　　　あります。
　　　　この関数は、係数テーブル関係のレジスタをセッテイングします。
　　　　またいったんＳＢＬのワークを読み込んで、内部処理を
　　　　行うため、SCL_SetConfigでの設定を先に行っておく必要があります。

■void slKtableRB(void *ktable_adr ,Uint16 mode);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、SCL_SglOnとslInitSystemをコールしておく必要が
　　　　あります。
　　　　この関数は、係数テーブル関係のレジスタをセッテイングします。
　　　　またいったんＳＢＬのワークを読み込んで、内部処理を
　　　　行うため、SCL_SetConfigでの設定を先に行っておく必要があります。
　　　　当然のことながら、ＳＧＬ側とＳＢＬ側で矛盾する設定をした場合
　　　　正常動作は期待できません。

■void slLookR(FIXED x,FIXED y);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、SCL_SglOnとslInitSystemをコールしておく必要が
　　　　あります。

■void slMakeKtable(void *adr);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、SCL_SglOnとslInitSystemをコールしておく必要が
　　　　あります。
　　　　ＳＧＬで使用されている係数テーブルをＶＲＡＭ上に作成します。
　　　　またいったんＳＢＬのワークを読み込んで、内部処理を
　　　　行うため、SCL_SetVramConfigでの設定を先に行っておく必要があります。
　　　　当然のことながら、矛盾する設定をした場合、正常動作は期待
　　　　できません。

■void slRparaInitSet(ROTSCROLL *ptr);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、SCL_SglOnとslInitSystemをコールしておく必要が
　　　　あります。
　　　　ＳＧＬで使用されている回転パラメータをセッティングします。
　　　　またいったんＳＢＬのワークを読み込んで、内部処理を
　　　　行うため、SCL_InitRotateTableでの設定を先に行っておく
　　　　必要があります。

■void slRparaMode(Uint16 mode);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、SCL_SglOnとslInitSystemをコールしておく必要が
　　　　あります。

■Bool slScrAutoDisp(Uint32 ptr);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、SCL_SglOnとslInitSystemをコールしておく必要が
　　　　あります。

■void slScrMatConv(void);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、SCL_SglOnとslInitSystemをコールしておく必要が
　　　　あります。

■void slScrMatSet(void);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、SCL_SglOnとslInitSystemをコールしておく必要が
　　　　あります。

■void slTVOff(void);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、slInitSystemをコールしておく必要が
　　　　あります。
　　　　TVをOFFします。具体的にはScl_s_reg.tvmodeの最上位ビットを
　　　　変更します。

■void slTVOn(void);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、slInitSystemをコールしておく必要が
　　　　あります。
　　　　TVをOFFします。具体的にはScl_s_reg.tvmodeの最上位ビットを
　　　　変更します。

■void slZoomR(FIXED x,FIXED y);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、SCL_SglOnとslInitSystemをコールしておく必要が
　　　　あります。

■void slZrotR(ANGLE angz);

　　　　ＳＧＬから移植されています。使用方法もＳＧＬに準じます。
　　　　初期化で、SCL_SglOnとslInitSystemをコールしておく必要が
　　　　あります。

************************************************************************

５．技術情報

　　■ＳＧＬとの融合のためSclRotreg構造体のサイズを変更した
　　　　具体的には、サイズを0x80から0x68に変更した。これの
　　　　大きさに依存するコードがある場合、注意が必要です。

　　■SclRotregBuffを配列からポインタに変更したため、これも
　　　　大きさに依存するコードがある場合、注意が必要です。

